The catalog of design pattern
=============================

Abstract Factory:
Provide an interface for creating families of related or dependent objects without specifying their concrete classes.

Adapter:
Convert the interface of a class into another interface clients expect.

Bridge:
Separate the construction of a complex object from its representation.

Chain of Responsibility:
Give more than one object a chance to handle the request.

Command:
Encapsulate a request as an object.

Composite:
Compose objects into tree structure.

Decorator:
Attach additional responsibilities to an object dynamically.

Facade:
Provide a unified interface to a set of interfaces in a subsystem

Factory Method:
Define an interface for creating an object, but let subclasses decide which class to instaniate.

Flyweight:
Use sharing to support large numbers of fine-grained objects efficiently.

Interpreter:
the interpreter pattern is a design pattern that specifies how to evaluate sentences in a language. 
The basic idea is to have a class for each symbol (terminal or nonterminal) in a specialized computer language. 
The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (interpret) the sentence.

Iterator:
Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

Mediator:
Define an object that encapsulates how a set of objects interact.

Memento:
Capture and externalize an objectâ€™s internal state without violating encapsulation.

Observer:
Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified updated automatically.

Prototype:
Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.

Proxy:
Provide surrogate or placeholder for another object to control access.

Singleton:
Ensure a class only has one instance.

State:
Allow an object to alter its behavior when its internal state changes.

Strategy:
Define a family of algorithms, encapsulate each one, and make them interchangeable.

Template Method:
Define the skeleton of an algorithm in an operation.  Subclasses can change the steps without modify the structure of the algorithm.

Visitor: 
Represent an operation to be performed on the elements of an object structure. Define a new operation without changing the classes of the elements on which it operates.
